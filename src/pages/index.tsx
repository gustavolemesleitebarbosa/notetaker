import { type NextPage } from 'next';
import type { Session } from 'next-auth';
import { getServerSession } from "next-auth/next";
import { useSession } from "next-auth/react";
import Head from "next/head";
import { useState, type CSSProperties } from "react";
import { authOptions } from "~/server/auth";
import { api, type RouterOutputs } from "~/utils/api";


import { useQueryClient } from '@tanstack/react-query';
import { getQueryKey } from '@trpc/react-query';
import { type GetServerSidePropsContext } from 'next';
import { signIn } from 'next-auth/react';
import ClipLoader from "react-spinners/ClipLoader";
import { Header } from "~/components/Header";
import { generateSSGHelper } from '~/server/helpers/ssgHelper';
import NoteCard from "../components/NoteCard";
import NoteEditor from "../components/NoteEditor";


const override: CSSProperties = {

  borderColor: "blue",
};
type Note = RouterOutputs["note"]["getAll"][0]

export type Props ={
  session: Session| null
}

const Home: NextPage<Props> = ({session} : Props) => {
  return (
    <>
      <Head>
        <title>NoteTaker</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main>
        <Header session/>
        <Content  />
      </main>
    </>
  );
};

export default Home;

const Content: React.FC = () => {

  type Topic = RouterOutputs["topic"]["getAll"][0]

  const { data: sessionData, status: sessionStatus } = useSession()
  const [selectedTopic, setSelectedTopic] = useState<Topic | null>()

  const { data: topics, refetch: refetchTopics, isLoading } = api.topic.getAll.useQuery(
    undefined,
    {
      enabled: sessionData?.user !== undefined,
      onSuccess: (data) => { setSelectedTopic(selectedTopic ?? data[0] ?? null) }
    }
  );

  const topicsListKey = getQueryKey(api.topic.getAll, undefined, 'query');

  const queryClient = useQueryClient()

  const createTopic = api.topic.create.useMutation({
    onMutate: async (newTopic) => {
      await queryClient.cancelQueries({ queryKey: topicsListKey })

      // get the cached values of 'topics'
      const previousTopics: Topic[] | undefined = queryClient.getQueryData(topicsListKey);

      // set the cached data with an added object
      // i.e the new topic posted

      queryClient.setQueryData(
        topicsListKey,
        previousTopics ? [...previousTopics, { title: newTopic.title, }] : [[], { title: newTopic.title, }]
      );
      return { previousTopics }
    },
    onError: (_err, _newTopic, context) => {
      queryClient.setQueryData([topicsListKey], context?.previousTopics)
    },
    onSettled() {
      void refetchTopics()
    },
  })

  const { data: notes, refetch: refetchNotes } = api.note.getAll.useQuery(
    { topicId: selectedTopic?.id ?? topics?.[0]?.id ?? "" },
    { enabled: sessionData?.user !== undefined }
  )

  const notesListKey = getQueryKey(api.note.getAll, { topicId: selectedTopic?.id ?? "" }, 'query');
  const createNote = api.note.create.useMutation({
    onMutate: async (newNote) => {

      await queryClient.cancelQueries({ queryKey: notesListKey })

      // get the cached values of 'topics'
      const previousNotes: Note[] | undefined = queryClient.getQueryData(notesListKey);

      // set the cached data with an added object
      // i.e the new note posted

      queryClient.setQueryData(
        notesListKey,
        previousNotes ? [...previousNotes, { title: newNote.title, content: newNote.content }] : [[], { title: newNote.title, }]
      );
      // return previousValue here 
      // we will use it in the next section
      return { previousNotes }
    },
    onError: (_err, _newNote, context) => {
      queryClient.setQueryData([notesListKey], context?.previousNotes)
    },
    onSettled: () => {
      void refetchNotes()
    },
  })

  const deleteNote = api.note.delete.useMutation({
    onMutate: async (newNote) => {
      await queryClient.cancelQueries({ queryKey: notesListKey })
      // get the cached values of 'topics'
      const previousNotes: Note[] | undefined = queryClient.getQueryData(notesListKey);

      // set the cached data with an added object
      // i.e the new note posted
      if (previousNotes)
        queryClient.setQueryData(
          notesListKey,
          [...previousNotes.filter(note => note.id !== newNote.id)]
        );
      return { previousNotes }
    },
    onError: (_err, _newNote, context) => {
      queryClient.setQueryData([notesListKey], context?.previousNotes)
    },
    onSettled: () => {
      void refetchNotes()
    }
  })

  if(sessionStatus === 'unauthenticated'){
    return <button  onClick={() => void signIn()} className="flex items-center justify-center col-span-4 w-full h-[80vh] text-4xl">
      Please sign in
    </button>
  }
   
  return (
    <div className="mx-5 mt-5 grid grid-cols-4 gap-2">
      {
        !topics  ?
          <div className="flex items-center justify-center col-span-4 h-[80vh]">
            
            <ClipLoader
              color={"##0679FE"}
              loading={true}
              cssOverride={override}
              size={150}
            />
          </div> :
          <>
            <div className="px-2">
              {!isLoading && topics ?
                <ul className="menu rounded-box w-56 bg-base-100 p-2">
                  {topics?.map((topic) => (
                    <li key={topic.id}>
                      <a href="#" onClick={(evt) => {
                        evt.preventDefault();
                        setSelectedTopic(topic)
                      }}>
                        {topic.title}
                      </a>
                    </li>
                  ))}
                </ul> : <>  {sessionStatus === 'unauthenticated' ? 'Please SIGN IN to see user saved topics  ' : 'Loading topics...'}</>
              }
              <div className="divider"></div>
              <input
                type="text"
                placeholder="New Topic"
                className="input-bordered input input-sm w-full"
                onKeyDown={(e) => {
                  if (e.key === "Enter") {
                    createTopic.mutate({
                      title: e.currentTarget.value,
                    })
                    e.currentTarget.value = ""
                  }
                }}
              />
            </div>
            <div className="col-span-3">
              <div>
                {notes?.map((note) => (
                  <div key={note.id} className=" mt-5">
                    <NoteCard
                      note={note}
                      onDelete={() => void deleteNote.mutate({ id: note.id })}
                    />
                  </div>
                ))}
              </div>
              <NoteEditor
                onSave={({ title, content }) => {
                  void createNote.mutate({
                    title,
                    content,
                    topicId: selectedTopic?.id ?? "",
                  })
                }}
              />
            </div>
          </>
      }
    </div>
  )
}


export async function getServerSideProps(context: GetServerSidePropsContext) {
  const session = await getServerSession(context.req, context.res, authOptions)
  const ssg = generateSSGHelper(session);
  // const id = context.params?.id as string;
  /*
   * Prefetching the `post.byId` query here.
   * `prefetch` does not return the result and never throws - if you need that behavior, use `fetch` instead.
   */
  let notes = null
  if (session) {
    const topics = await ssg.topic.getAll.fetch();
    if (topics.length && topics[0]) {
      notes = await ssg.note.getAll.fetch({ topicId: topics[0].id });
      // Make sure to return { props: { trpcState: ssg.dehydrate() } }
      notes = notes.map(note => ({
        ...note,
        createdAt: note.createdAt.toISOString(),
        updatedAt: note.updatedAt.toISOString()
      }));
    }
  }

  return {
    props: {
      trpcState: ssg.dehydrate(),
      session
    },
  };
}

